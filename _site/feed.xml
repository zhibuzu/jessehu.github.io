<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-10-10T21:36:31+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">代码仔</title><subtitle>技术、人生感悟，大数据，架构、策略等</subtitle><entry><title type="html">pixel、分辨率、ppi、dpi、dp、dip区别及转换</title><link href="http://localhost:4000/learn/2019/10/10/%E5%83%8F%E7%B4%A0px-%E5%88%86%E8%BE%A8%E7%8E%87-ppi-dpi-dp(dip).html" rel="alternate" type="text/html" title="pixel、分辨率、ppi、dpi、dp、dip区别及转换" /><published>2019-10-10T20:56:00+08:00</published><updated>2019-10-10T20:56:00+08:00</updated><id>http://localhost:4000/learn/2019/10/10/%E5%83%8F%E7%B4%A0px%E3%80%81%E5%88%86%E8%BE%A8%E7%8E%87%E3%80%81ppi%E3%80%81dpi%E3%80%81dp(dip)</id><content type="html" xml:base="http://localhost:4000/learn/2019/10/10/%E5%83%8F%E7%B4%A0px-%E5%88%86%E8%BE%A8%E7%8E%87-ppi-dpi-dp(dip).html">&lt;p&gt;屏幕尺寸（Screen Size）： 屏幕对角线的长度。iPhone5屏幕尺寸为4英寸、iPhone6屏幕尺寸为4.7英寸，指的是显示屏对角线的长度。 1 inch = 2.54cm = 25.4mm
分辨率：屏幕上的像素总数。常用的表现形式如：1280x720, 1920x1080等。&lt;/p&gt;

&lt;p&gt;px，pixel，像素，电子屏幕上组成一幅图画或image的基本单元。
pt， point，点，印刷行业常用单位，等于1/72英寸。
ppi，pixel per inch，每英寸像素数，值越高，屏幕越细腻。
dpi， dot per inch，每英寸多少点，该值越高，则图片越细腻。
dp，dip， Density-independent pixel，安卓开发用的长度单位。以160ppi为标准，和iPhone的scale差不多的意思。安卓用dp适配，系统会自动将dp转换为px。当屏幕像素点密度为160ppi时，1dp=1px。&lt;/p&gt;

&lt;h4 id=&quot;一pt与px--1pt--ppi--72px&quot;&gt;一，pt与px ： 1pt = (ppi / 72)px。&lt;/h4&gt;

&lt;p&gt;当图片的分辨率是72ppi（dpi）时，1pt = 1px；
当图片的分辨率是72*2ppi（dpi）时，1pt = 2px；&lt;/p&gt;

&lt;h4 id=&quot;二ppi与dpidpippi&quot;&gt;二，ppi与dpi：dpi=ppi&lt;/h4&gt;

&lt;p&gt;dpi最初用于衡量打印物上每英寸的点数密度，DPI值越大图片越精细。当DPI的概念用在计算机屏幕上时，就应称之为ppi。同理： PPI就是计算机屏幕上每英寸可以显示的像素点的数量。在电子屏幕显示中ppi和dpi是一样的。&lt;/p&gt;

&lt;h4 id=&quot;三ppi计算方法&quot;&gt;三，ppi计算方法&lt;/h4&gt;

&lt;p&gt;假设屏幕分辨率为W&lt;em&gt;H(px)，物理尺寸为a&lt;/em&gt;b(inch)，
则我们常说的屏幕尺寸c（如5.0英寸）其实是对角线的长度，因此&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;c = \sqrt{a^2 + b^2}&lt;/script&gt;
​&lt;/p&gt;

&lt;p&gt;​											&lt;u&gt;勾股定理&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;则像素密度（PPI），指的是屏幕单位长度的像素数&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;DPI = PPI = W/a = H/b&lt;/script&gt;
​&lt;/p&gt;

&lt;p&gt;​										&lt;u&gt;屏幕密度&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;由此我们推理出：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;DPI^2 = PPI^2 = (W/a)^2 = (H/b)^2 = (W^2 + H^2)/(a^2 + b^2) = (W^2 + H^2)/c^2&lt;/script&gt;

&lt;p&gt;​&lt;/p&gt;

&lt;p&gt;​									&lt;u&gt;屏幕密度&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;因此我们可以得出PPI（ DPI）计算公式：&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;DPI = PPI = \sqrt{W^2 + H^2}/c&lt;/script&gt;
​&lt;/p&gt;

&lt;p&gt;​									&lt;u&gt;PPI（ DPI）计算公式&lt;/u&gt;&lt;/p&gt;

&lt;p&gt;eg：iphone6分辨率1334*750px，尺寸4.7英寸&lt;/p&gt;

&lt;p&gt;则其
&lt;script type=&quot;math/tex&quot;&gt;PPI = \sqrt{1334^2+750^2}/4.7 = 326&lt;/script&gt;
​&lt;/p&gt;

&lt;p&gt;​										&lt;u&gt;iphone6像素密度&lt;/u&gt;&lt;/p&gt;

&lt;h4 id=&quot;四px和dp&quot;&gt;四，px和dp&lt;/h4&gt;

&lt;p&gt;dp，独立像素，虚拟单位，又称设备无关像素。1dp的长度相当于一个160dpi的屏幕上一个物理像素的长度。而160dpi的屏幕则是被android定义为基准的屏幕（mdpi）。在app运行的时候，android会将dp转为实际像素进行布局。转换的公式为：
&lt;script type=&quot;math/tex&quot;&gt;px = dp * (160 / dpi)。&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;dp为安卓开发时的基本长度单位，根据不同的屏幕分辨率，与px有不同的对应关系。根据其像素密度，我们将安卓端屏幕分为以下几种规格：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/images/WX20191010-211819.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1dp即为当屏幕密度值为160ppi时，1pt=1px。则，在上表中，当密度为mdpi时，1dp = 1px。 以mdpi为标准，上表中屏幕的密度值比分别为：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;ldpi : mdpi : hdpi : xhdpi : xxhpi = 0.75 : 1 : 1.5 : 2 : 3&lt;/script&gt;

&lt;p&gt;即，在xhdpi的密度下，1dp=2px；在hdpi情况下，1dp=1.5px。其他类推。&lt;/p&gt;</content><author><name></name></author><summary type="html">屏幕尺寸（Screen Size）： 屏幕对角线的长度。iPhone5屏幕尺寸为4英寸、iPhone6屏幕尺寸为4.7英寸，指的是显示屏对角线的长度。 1 inch = 2.54cm = 25.4mm 分辨率：屏幕上的像素总数。常用的表现形式如：1280x720, 1920x1080等。</summary></entry><entry><title type="html">进程间通信方式</title><link href="http://localhost:4000/2019/09/25/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.html" rel="alternate" type="text/html" title="进程间通信方式" /><published>2019-09-25T00:00:00+08:00</published><updated>2019-09-25T00:00:00+08:00</updated><id>http://localhost:4000/2019/09/25/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F</id><content type="html" xml:base="http://localhost:4000/2019/09/25/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.html">&lt;h2 id=&quot;进程间通信的几种方式&quot;&gt;进程间通信的几种方式&lt;/h2&gt;

&lt;p&gt;介绍一下进程间通信有几种方式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;共享内存(Share memory)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;匿名管道(pipe)：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;管道是一种半双工的通信方式，数据只能&lt;strong&gt;单向流动&lt;/strong&gt;，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指&lt;strong&gt;父子进程关系&lt;/strong&gt;。&lt;/p&gt;

        &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 需要的头文件&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;unistd.h&amp;gt;
&lt;/span&gt;    
&lt;span class=&quot;c1&quot;&gt;// 通过pipe()函数来创建匿名管道&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 返回值：成功返回0，失败返回-1&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// fd参数返回两个文件描述符&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// fd[0]指向管道的读端，fd[1]指向管道的写端&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// fd[1]的输出是fd[0]的输入。&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;————————————————&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;版权声明：本文为&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CSDN&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;博主「&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Violet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Guo&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;」的原创文章，遵循&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CC&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;4.0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SA&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;版权协议，转载请附上原文出处链接及本声明。&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;原文链接：&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;https&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//blog.csdn.net/violet_echo_0908/article/details/51201278&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;信号量（Signal）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;套接字（Socket）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">进程间通信的几种方式</summary></entry><entry><title type="html">使用socket实现一个简单的进程间通信程序</title><link href="http://localhost:4000/2019/09/25/%E4%BD%BF%E7%94%A8socket%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F.html" rel="alternate" type="text/html" title="使用socket实现一个简单的进程间通信程序" /><published>2019-09-25T00:00:00+08:00</published><updated>2019-09-25T00:00:00+08:00</updated><id>http://localhost:4000/2019/09/25/%E4%BD%BF%E7%94%A8socket%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F</id><content type="html" xml:base="http://localhost:4000/2019/09/25/%E4%BD%BF%E7%94%A8socket%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F.html">&lt;ul&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">C函数库</title><link href="http://localhost:4000/2019/09/25/c%E5%87%BD%E6%95%B0%E5%BA%93.html" rel="alternate" type="text/html" title="C函数库" /><published>2019-09-25T00:00:00+08:00</published><updated>2019-09-25T00:00:00+08:00</updated><id>http://localhost:4000/2019/09/25/c%E5%87%BD%E6%95%B0%E5%BA%93</id><content type="html" xml:base="http://localhost:4000/2019/09/25/c%E5%87%BD%E6%95%B0%E5%BA%93.html">&lt;ol&gt;
  &lt;li&gt;
    &lt;ctype.h&gt;：包含用来测试某个特征字符的函数的函数原型，以及用来转换大小写字母的函数原型；
&lt;/ctype.h&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;errno.h&gt;：定义用来报告错误条件的宏；
&lt;/errno.h&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;float.h&gt;：包含系统的浮点数大小限制；
&lt;/float.h&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;math.h&gt;：包含数学库函数的函数原型；
&lt;/math.h&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;stddef.h&gt;：包含执行某些计算 C 所用的常见的函数定义；
&lt;/stddef.h&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;stdio.h&gt;：包含标准输入输出库函数的函数原型，以及他们所用的信息；
&lt;/stdio.h&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;stdlib.h&gt;：包含数字转换到文本，以及文本转换到数字的函数原型，还有内存分配、随机数字以及其他实用函数的函数原型；
&lt;/stdlib.h&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;string.h&gt;：包含字符串处理函数的函数原型；
&lt;/string.h&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;time.h&gt;：包含时间和日期操作的函数原型和类型；
&lt;/time.h&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;stdarg.h&gt;：包含函数原型和宏，用于处理未知数值和类型的函数的参数列表；
&lt;/stdarg.h&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;signal.h&gt;：包含函数原型和宏，用于处理程序执行期间可能出现的各种条件；
&lt;/signal.h&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;setjmp.h&gt;：包含可以绕过一般函数调用并返回序列的函数的原型，即非局部跳转；
&lt;/setjmp.h&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;locale.h&gt;：包含函数原型和其他信息，使程序可以针对所运行的地区进行修改。
&lt;/locale.h&gt;
  &lt;/li&gt;
  &lt;li&gt;地区的表示方法可以使计算机系统处理不同的数据表达约定，如全世界的日期、时间、美元数和大数字；&lt;/li&gt;
  &lt;li&gt;
    &lt;assert.h&gt;：包含宏和信息，用于进行诊断，帮助程序调试。
&lt;/assert.h&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">：包含用来测试某个特征字符的函数的函数原型，以及用来转换大小写字母的函数原型； ：定义用来报告错误条件的宏； ：包含系统的浮点数大小限制； ：包含数学库函数的函数原型； ：包含执行某些计算 C 所用的常见的函数定义； ：包含标准输入输出库函数的函数原型，以及他们所用的信息； ：包含数字转换到文本，以及文本转换到数字的函数原型，还有内存分配、随机数字以及其他实用函数的函数原型； ：包含字符串处理函数的函数原型； ：包含时间和日期操作的函数原型和类型； ：包含函数原型和宏，用于处理未知数值和类型的函数的参数列表； ：包含函数原型和宏，用于处理程序执行期间可能出现的各种条件； ：包含可以绕过一般函数调用并返回序列的函数的原型，即非局部跳转； ：包含函数原型和其他信息，使程序可以针对所运行的地区进行修改。 地区的表示方法可以使计算机系统处理不同的数据表达约定，如全世界的日期、时间、美元数和大数字； ：包含宏和信息，用于进行诊断，帮助程序调试。</summary></entry><entry><title type="html">CAP定理</title><link href="http://localhost:4000/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2019/09/06/CAP%E5%AE%9A%E7%90%86.html" rel="alternate" type="text/html" title="CAP定理" /><published>2019-09-06T20:00:00+08:00</published><updated>2019-09-06T20:00:00+08:00</updated><id>http://localhost:4000/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2019/09/06/CAP%E5%AE%9A%E7%90%86</id><content type="html" xml:base="http://localhost:4000/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/2019/09/06/CAP%E5%AE%9A%E7%90%86.html">&lt;h2 id=&quot;cap定理&quot;&gt;CAP定理&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%90%86%E8%AB%96%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8&quot;&gt;理论计算机科学&lt;/a&gt;中，&lt;strong&gt;CAP定理&lt;/strong&gt;（CAP theorem），又被称作&lt;strong&gt;布鲁尔定理&lt;/strong&gt;（Brewer’s theorem），它指出对于一个&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97&quot;&gt;分布式计算系统&lt;/a&gt;来说，不可能同时满足以下三点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一致性（Consistency）：每一次读获取写入的最新数据或者一个错误（Every read receives the most recent write or an error）&lt;/li&gt;
  &lt;li&gt;可用性（Availability）：每次请求都能获取到非错的响应—但是不保证获取的数据为最近写入的最新数据（Every request receives a (non-error) response – without the guarantee that it contains the most recent write）&lt;/li&gt;
  &lt;li&gt;分区容错性（Partition tolerance）：系统不中断操作，尽管节点间的通信可能出现任意数量的消息被丢失（或延迟）（The system continues to operate despite an arbitrary number of messages being dropped (or delayed) by the network between nodes）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当网络分区通信发现错误时，我们可以有两种选择：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;取消当前操作，降低了可用性，但保证了一致性；&lt;/li&gt;
  &lt;li&gt;继续当前操作，提高了可用性，但保证不了一致性；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实际上，CAP定理暗示了在网络分区存在的情况下，要么选择&lt;strong&gt;一致性&lt;/strong&gt; 要么选择&lt;strong&gt;可用性&lt;/strong&gt;。注意这里的&lt;strong&gt;一致性&lt;/strong&gt;不同于&lt;strong&gt;ACID 数据库事物&lt;/strong&gt;中的&lt;strong&gt;一致性&lt;/strong&gt;保证。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;参考资源&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;轻松理解CAP理论 - 房东的狗的文章 - 知乎
https://zhuanlan.zhihu.com/p/50990721&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">CAP定理</summary></entry><entry><title type="html">常用Git命令清单</title><link href="http://localhost:4000/git/2019/08/26/%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.html" rel="alternate" type="text/html" title="常用Git命令清单" /><published>2019-08-26T21:16:08+08:00</published><updated>2019-08-26T21:16:08+08:00</updated><id>http://localhost:4000/git/2019/08/26/%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95</id><content type="html" xml:base="http://localhost:4000/git/2019/08/26/%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.html">&lt;p&gt;我每天使用 Git ，但是很多命令记不住。&lt;/p&gt;

&lt;p&gt;一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/images/bg2015120901.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Workspace：工作区&lt;/li&gt;
    &lt;li&gt;Index / Stage：暂存区&lt;/li&gt;
    &lt;li&gt;Repository：仓库区（或本地仓库）&lt;/li&gt;
    &lt;li&gt;Remote：远程仓库&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;一新建代码库&quot;&gt;一、新建代码库&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 在当前目录新建一个Git代码库&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git init

&lt;span class=&quot;c&quot;&gt;# 新建一个目录，将其初始化为Git代码库&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git init &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;project-name]

&lt;span class=&quot;c&quot;&gt;# 下载一个项目和它的整个代码历史&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;url]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;二配置&quot;&gt;二、配置&lt;/h2&gt;

&lt;p&gt;Git的设置文件为&lt;code class=&quot;highlighter-rouge&quot;&gt;.gitconfig&lt;/code&gt;，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 显示当前的Git配置&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git config &lt;span class=&quot;nt&quot;&gt;--list&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 编辑Git配置文件&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git config &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 设置提交代码时的用户信息&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git config &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; user.name &lt;span class=&quot;s2&quot;&gt;&quot;[name]&quot;&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git config &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;--global&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; user.email &lt;span class=&quot;s2&quot;&gt;&quot;[email address]&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;三增加删除文件&quot;&gt;三、增加/删除文件&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 添加指定文件到暂存区&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git add &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file1] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file2] ...

&lt;span class=&quot;c&quot;&gt;# 添加指定目录到暂存区，包括子目录&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git add &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 添加当前目录的所有文件到暂存区&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git add &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 添加每个变化前，都会要求确认&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 对于同一个文件的多处变化，可以实现分次提交&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git add &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 删除工作区文件，并且将这次删除放入暂存区&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git &lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file1] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file2] ...

&lt;span class=&quot;c&quot;&gt;# 停止追踪指定文件，但该文件会保留在工作区&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git &lt;span class=&quot;nb&quot;&gt;rm&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--cached&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file]

&lt;span class=&quot;c&quot;&gt;# 改名文件，并且将这个改名放入暂存区&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git &lt;span class=&quot;nb&quot;&gt;mv&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file-original] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file-renamed]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;四代码提交&quot;&gt;四、代码提交&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 提交暂存区到仓库区&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git commit &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;message]

&lt;span class=&quot;c&quot;&gt;# 提交暂存区的指定文件到仓库区&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git commit &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file1] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file2] ... &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;message]

&lt;span class=&quot;c&quot;&gt;# 提交工作区自上次commit之后的变化，直接到仓库区&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git commit &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 提交时显示所有diff信息&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git commit &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 使用一次新的commit，替代上一次提交&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 如果代码没有任何新变化，则用来改写上一次commit的提交信息&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git commit &lt;span class=&quot;nt&quot;&gt;--amend&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;message]

&lt;span class=&quot;c&quot;&gt;# 重做上一次commit，并包括指定文件的新变化&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git commit &lt;span class=&quot;nt&quot;&gt;--amend&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file1] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file2] ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;五分支&quot;&gt;五、分支&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 列出所有本地分支&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git branch

&lt;span class=&quot;c&quot;&gt;# 列出所有远程分支&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git branch &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 列出所有本地分支和远程分支&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git branch &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 新建一个分支，但依然停留在当前分支&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git branch &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;branch-name]

&lt;span class=&quot;c&quot;&gt;# 新建一个分支，并切换到该分支&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git checkout &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;branch]

&lt;span class=&quot;c&quot;&gt;# 新建一个分支，指向指定commit&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git branch &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;branch] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;commit]

&lt;span class=&quot;c&quot;&gt;# 新建一个分支，与指定的远程分支建立追踪关系&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git branch &lt;span class=&quot;nt&quot;&gt;--track&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;branch] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;remote-branch]

&lt;span class=&quot;c&quot;&gt;# 切换到指定分支，并更新工作区&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git checkout &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;branch-name]

&lt;span class=&quot;c&quot;&gt;# 切换到上一个分支&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git checkout -

&lt;span class=&quot;c&quot;&gt;# 建立追踪关系，在现有分支与指定的远程分支之间&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git branch &lt;span class=&quot;nt&quot;&gt;--set-upstream&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;branch] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;remote-branch]

&lt;span class=&quot;c&quot;&gt;# 合并指定分支到当前分支&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git merge &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;branch]

&lt;span class=&quot;c&quot;&gt;# 选择一个commit，合并进当前分支&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git cherry-pick &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;commit]

&lt;span class=&quot;c&quot;&gt;# 删除分支&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git branch &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;branch-name]

&lt;span class=&quot;c&quot;&gt;# 删除远程分支&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git push origin &lt;span class=&quot;nt&quot;&gt;--delete&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;branch-name]
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git branch &lt;span class=&quot;nt&quot;&gt;-dr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;remote/branch]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;六标签&quot;&gt;六、标签&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 列出所有tag&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git tag

&lt;span class=&quot;c&quot;&gt;# 新建一个tag在当前commit&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git tag &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;tag]

&lt;span class=&quot;c&quot;&gt;# 新建一个tag在指定commit&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git tag &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;tag] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;commit]

&lt;span class=&quot;c&quot;&gt;# 删除本地tag&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git tag &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;tag]

&lt;span class=&quot;c&quot;&gt;# 删除远程tag&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git push origin :refs/tags/[tagName]

&lt;span class=&quot;c&quot;&gt;# 查看tag信息&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git show &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;tag]

&lt;span class=&quot;c&quot;&gt;# 提交指定tag&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git push &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;remote] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;tag]

&lt;span class=&quot;c&quot;&gt;# 提交所有tag&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git push &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;remote] &lt;span class=&quot;nt&quot;&gt;--tags&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 新建一个分支，指向某个tag&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git checkout &lt;span class=&quot;nt&quot;&gt;-b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;branch] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;tag]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;七查看信息&quot;&gt;七、查看信息&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 显示有变更的文件&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git status

&lt;span class=&quot;c&quot;&gt;# 显示当前分支的版本历史&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git log

&lt;span class=&quot;c&quot;&gt;# 显示commit历史，以及每次commit发生变更的文件&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git log &lt;span class=&quot;nt&quot;&gt;--stat&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 搜索提交历史，根据关键词&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git log &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;keyword]

&lt;span class=&quot;c&quot;&gt;# 显示某个commit之后的所有变动，每个commit占据一行&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git log &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;tag] HEAD &lt;span class=&quot;nt&quot;&gt;--pretty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;format:%s

&lt;span class=&quot;c&quot;&gt;# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git log &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;tag] HEAD &lt;span class=&quot;nt&quot;&gt;--grep&lt;/span&gt; feature

&lt;span class=&quot;c&quot;&gt;# 显示某个文件的版本历史，包括文件改名&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git log &lt;span class=&quot;nt&quot;&gt;--follow&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file]
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git whatchanged &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file]

&lt;span class=&quot;c&quot;&gt;# 显示指定文件相关的每一次diff&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git log &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file]

&lt;span class=&quot;c&quot;&gt;# 显示过去5次提交&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git log &lt;span class=&quot;nt&quot;&gt;-5&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--pretty&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--oneline&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 显示所有提交过的用户，按提交次数排序&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git shortlog &lt;span class=&quot;nt&quot;&gt;-sn&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 显示指定文件是什么人在什么时间修改过&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git blame &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file]

&lt;span class=&quot;c&quot;&gt;# 显示暂存区和工作区的差异&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git diff

&lt;span class=&quot;c&quot;&gt;# 显示暂存区和上一个commit的差异&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git diff &lt;span class=&quot;nt&quot;&gt;--cached&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file]

&lt;span class=&quot;c&quot;&gt;# 显示工作区与当前分支最新commit之间的差异&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git diff HEAD

&lt;span class=&quot;c&quot;&gt;# 显示两次提交之间的差异&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git diff &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;first-branch]...[second-branch]

&lt;span class=&quot;c&quot;&gt;# 显示今天你写了多少行代码&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git diff &lt;span class=&quot;nt&quot;&gt;--shortstat&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;@{0 day ago}&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 显示某次提交的元数据和内容变化&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git show &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;commit]

&lt;span class=&quot;c&quot;&gt;# 显示某次提交发生变化的文件&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git show &lt;span class=&quot;nt&quot;&gt;--name-only&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;commit]

&lt;span class=&quot;c&quot;&gt;# 显示某次提交时，某个文件的内容&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git show &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;commit]:[filename]

&lt;span class=&quot;c&quot;&gt;# 显示当前分支的最近几次提交&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git reflog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;八远程同步&quot;&gt;八、远程同步&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 下载远程仓库的所有变动&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git fetch &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;remote]

&lt;span class=&quot;c&quot;&gt;# 显示所有远程仓库&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git remote &lt;span class=&quot;nt&quot;&gt;-v&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 显示某个远程仓库的信息&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git remote show &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;remote]

&lt;span class=&quot;c&quot;&gt;# 增加一个新的远程仓库，并命名&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git remote add &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;shortname] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;url]

&lt;span class=&quot;c&quot;&gt;# 取回远程仓库的变化，并与本地分支合并&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git pull &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;remote] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;branch]

&lt;span class=&quot;c&quot;&gt;# 上传本地指定分支到远程仓库&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git push &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;remote] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;branch]

&lt;span class=&quot;c&quot;&gt;# 强行推送当前分支到远程仓库，即使有冲突&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git push &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;remote] &lt;span class=&quot;nt&quot;&gt;--force&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 推送所有分支到远程仓库&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git push &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;remote] &lt;span class=&quot;nt&quot;&gt;--all&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;九撤销&quot;&gt;九、撤销&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 恢复暂存区的指定文件到工作区&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git checkout &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file]

&lt;span class=&quot;c&quot;&gt;# 恢复某个commit的指定文件到暂存区和工作区&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git checkout &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;commit] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file]

&lt;span class=&quot;c&quot;&gt;# 恢复暂存区的所有文件到工作区&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git checkout &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git reset &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file]

&lt;span class=&quot;c&quot;&gt;# 重置暂存区与工作区，与上一次commit保持一致&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git reset &lt;span class=&quot;nt&quot;&gt;--hard&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git reset &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;commit]

&lt;span class=&quot;c&quot;&gt;# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git reset &lt;span class=&quot;nt&quot;&gt;--hard&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;commit]

&lt;span class=&quot;c&quot;&gt;# 重置当前HEAD为指定commit，但保持暂存区和工作区不变&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git reset &lt;span class=&quot;nt&quot;&gt;--keep&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;commit]

&lt;span class=&quot;c&quot;&gt;# 新建一个commit，用来撤销指定commit&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 后者的所有变化都将被前者抵消，并且应用到当前分支&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git revert &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;commit]

&lt;span class=&quot;c&quot;&gt;# 暂时将未提交的变化移除，稍后再移入&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git stash
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git stash pop
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;十其他&quot;&gt;十、其他&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 生成一个可供发布的压缩包&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git archive
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;
&lt;/blockquote&gt;</content><author><name></name></author><summary type="html">我每天使用 Git ，但是很多命令记不住。</summary></entry><entry><title type="html">C/C++易混淆概念记录</title><link href="http://localhost:4000/learn/2019/08/19/CC++%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5.html" rel="alternate" type="text/html" title="C/C++易混淆概念记录" /><published>2019-08-19T23:12:00+08:00</published><updated>2019-08-19T23:12:00+08:00</updated><id>http://localhost:4000/learn/2019/08/19/CC++%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5</id><content type="html" xml:base="http://localhost:4000/learn/2019/08/19/CC++%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5.html">&lt;h2 id=&quot;基础&quot;&gt;基础&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;指针为NULL与nullptr的区别？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;void与void* 的区别？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数组指针与指针数组区别？&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;数组指针（也称行指针）
定义 int (*p)[n];
()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。
   
如要将二维数组赋给一指针，应这样赋值：
int a[3][4];
int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。
 p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&amp;amp;a[0][0]
 p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]
   
所以数组指针也称指向一维数组的指针，亦称行指针。
   
指针数组
定义 int *p[n];
[]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1是错误的，这样赋值也是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]...p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 *p=a; 这里*p表示指针数组第一个元素的值，a的首地址的值。
如要将二维数组赋给一指针数组:
int *p[3];
int a[3][4];
for(i=0;i&amp;lt;3;i++)
p[i]=a[i];
这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]
所以要分别赋值。
   
这样两者的区别就豁然开朗了，数组指针只是一个指针变量，似乎是C语言里专门用来指向二维数组的，它占有内存中一个指针的存储空间。指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间。
还需要说明的一点就是，同时用来指向二维数组时，其引用和用数组名引用都是一样的。
比如要表示数组中i行j列一个元素：
*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]
   
    
   
优先级：()&amp;gt;[]&amp;gt;*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;int / long/ long long？&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;On major 32-bit platforms:
   
int is 32 bits
long is 32 bits as well
long long is 64 bits
   
On major 64-bit platforms:
   
int is 32 bits
long is either 32 or 64 bits
long long is 64 bits as well
   
Going by the standard:
   
int must be at least 16 bits
long must be at least 32 bits
long long must be at least 64 bits
   
Correct me if I'm wrong.
   
If you need a specific integer size for a particular application, rather than trusting the compiler to pick the size you want, #include &amp;lt;stdint.h&amp;gt; (or &amp;lt;cstdint&amp;gt;) so you can use these types:
   
int8_t and uint8_t
int16_t and uint16_t
int32_t and uint32_t
int64_t and uint64_t
You may also be interested in #include &amp;lt;stddef.h&amp;gt; (or &amp;lt;cstddef&amp;gt;):
   
size_t
ptrdiff_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数组名为a，a 与 &amp;amp;a的区别？&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a: 指向数组第一个元素a[0]的指针，即存储了数组第一个元素存放的地址；
&amp;amp;a: 指向了数组a的指针，存储的是数组首地址；
a 与 &amp;amp;a都是指针，区别在于指向的类型不同。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;高级&quot;&gt;高级&lt;/h2&gt;</content><author><name></name></author><summary type="html">基础</summary></entry><entry><title type="html">hadoop streaming 多路输出</title><link href="http://localhost:4000/learn/2019/06/10/hadoop-streaming-%E5%A4%9A%E8%B7%AF%E8%BE%93%E5%87%BA.html" rel="alternate" type="text/html" title="hadoop streaming 多路输出" /><published>2019-06-10T21:12:00+08:00</published><updated>2019-06-10T21:12:00+08:00</updated><id>http://localhost:4000/learn/2019/06/10/hadoop-streaming-%E5%A4%9A%E8%B7%AF%E8%BE%93%E5%87%BA</id><content type="html" xml:base="http://localhost:4000/learn/2019/06/10/hadoop-streaming-%E5%A4%9A%E8%B7%AF%E8%BE%93%E5%87%BA.html">&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;多路输出指定outputformat&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-outputformat org.apache.hadoop.mapred.lib.SuffixMultipleTextOutputFormat&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-outputformat org.apache.hadoop.mapred.lib.SuffixMultipleSequenceFileOutputFormat&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在reduce的输出&amp;lt;key, value&amp;gt;变为输出&amp;lt;key, value#X&amp;gt;, #X后缀中X是A~Z的26个英文字母&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;坑：对于TextInputFormat，reduce输出数据经常是一行一行的文本，如果一行的中间没有”\t”的话，就代表value为空，如果直接将”#X”后缀放在行尾，”#X”会作为key的一部分而不是value的一部分（因为加上后缀后一行中间仍然没有”\t”）这样会导致出错，解决的方式是在#X后缀前面添加”\t”使它变成value的一部分而不是key的一部分&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">多路输出指定outputformat</summary></entry><entry><title type="html">taglist-vim快捷键</title><link href="http://localhost:4000/learn/2019/06/10/taglist-vim%E5%BF%AB%E6%8D%B7%E9%94%AE.html" rel="alternate" type="text/html" title="taglist-vim快捷键" /><published>2019-06-10T21:04:00+08:00</published><updated>2019-06-10T21:04:00+08:00</updated><id>http://localhost:4000/learn/2019/06/10/taglist-vim%E5%BF%AB%E6%8D%B7%E9%94%AE</id><content type="html" xml:base="http://localhost:4000/learn/2019/06/10/taglist-vim%E5%BF%AB%E6%8D%B7%E9%94%AE.html">&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&amp;lt;CR&amp;gt;          跳到光标下tag所定义的位置，用鼠标双击此tag功能也一样
o             在一个新打开的窗口中显示光标下tag
&amp;lt;Space&amp;gt;       显示光标下tag的原型定义
u             更新taglist窗口中的tag
s             更改排序方式，在按名字排序和按出现顺序排序间切换
x             taglist窗口放大和缩小，方便查看较长的tag
+             打开一个折叠，同zo
-             将tag折叠起来，同zc
*             打开所有的折叠，同zR
=             将所有tag折叠起来，同zM
[[            跳到前一个文件
]]            跳到后一个文件
q             关闭taglist窗口
&amp;lt;F1&amp;gt;          显示帮助 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><summary type="html">```</summary></entry><entry><title type="html">hadoop partitioner类</title><link href="http://localhost:4000/learn/2019/06/10/hadoop-Partitioner%E7%B1%BB.html" rel="alternate" type="text/html" title="hadoop partitioner类" /><published>2019-06-10T21:04:00+08:00</published><updated>2019-06-10T21:04:00+08:00</updated><id>http://localhost:4000/learn/2019/06/10/hadoop-Partitioner%E7%B1%BB</id><content type="html" xml:base="http://localhost:4000/learn/2019/06/10/hadoop-Partitioner%E7%B1%BB.html">&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;指定partitioner类（二次排序）&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-partitioner org.apache.hadoop.mapred.lib.KeyFieldBasedPartitioner&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定自定义方法切分行来形成key/value对&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-jobconf stream.reduce.output.field.separator=SEP # 指定分隔符，默认是tab符&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-jobconf stream.num.reduce.output.fields=NUM # 指定在第n（n&amp;gt;=1）个分隔符分隔，而不是默认的第1个&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定map输出数据分桶的列数（基于key值的前缀）&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;map.output.key.field.separator=. # 指定切分map输出的分隔符为. &lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;num.key.fields.for.partition=2 # 指定使用key的前2个块部分来切分map输出&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">指定partitioner类（二次排序）</summary></entry></feed>