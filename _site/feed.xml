<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US"><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en-US" /><updated>2019-09-22T02:34:32-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Your title</title><subtitle>A description for your page.
</subtitle><author><name>Your Name</name></author><entry><title type="html">你的存在本身就是世界上最大的奇迹</title><link href="http://localhost:4000/%E6%84%9F%E6%82%9F/2019/09/21/%E4%BD%A0%E7%9A%84%E5%AD%98%E5%9C%A8%E6%9C%AC%E8%BA%AB%E5%B0%B1%E6%98%AF%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E5%A4%A7%E7%9A%84%E5%A5%87%E8%BF%B9/" rel="alternate" type="text/html" title="你的存在本身就是世界上最大的奇迹" /><published>2019-09-21T19:51:00-07:00</published><updated>2019-09-21T19:51:00-07:00</updated><id>http://localhost:4000/%E6%84%9F%E6%82%9F/2019/09/21/%E4%BD%A0%E7%9A%84%E5%AD%98%E5%9C%A8%E6%9C%AC%E8%BA%AB%E5%B0%B1%E6%98%AF%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E5%A4%A7%E7%9A%84%E5%A5%87%E8%BF%B9</id><content type="html" xml:base="http://localhost:4000/%E6%84%9F%E6%82%9F/2019/09/21/%E4%BD%A0%E7%9A%84%E5%AD%98%E5%9C%A8%E6%9C%AC%E8%BA%AB%E5%B0%B1%E6%98%AF%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E5%A4%A7%E7%9A%84%E5%A5%87%E8%BF%B9/">&lt;p&gt;当我们混成了一个格子间的上班族，每天沿着一成不变的线路，一动不动的车流或人肉罐头似的地铁去贩卖我们的时间，赚取生存、养家的资本，难免在某些时刻觉得自己平庸，但在大部分时刻麻木如地上的蚂蚁。&lt;/p&gt;

&lt;p&gt;可是突然有一天我想到此刻你自觉平庸的自己存在于世本身就是世界上最大的奇迹。往上追溯的话，你经历了人类几百万年来从未中断的生息繁衍，这件事你仔细想想有多难！你的祖先中从原始人开始，任何一个人被狼豺虎豹吃掉，被森林大火烧死，无法适应从树上到地上直立行走的生活，你就不可能存在，存在也不是现在的你。穿过强敌环伺，天地不仁的环境，在幽暗的时间长河里，奇迹延续着发生，还能有你。&lt;/p&gt;

&lt;p&gt;所以让你这个奇迹继续发生下去吧！&lt;/p&gt;</content><author><name>Your Name</name></author><category term="生活感悟" /><category term="灵感" /><summary type="html">当我们混成了一个格子间的上班族，每天沿着一成不变的线路，一动不动的车流或人肉罐头似的地铁去贩卖我们的时间，赚取生存、养家的资本，难免在某些时刻觉得自己平庸，但在大部分时刻麻木如地上的蚂蚁。</summary></entry><entry><title type="html">多态基类声明virtual析构函数</title><link href="http://localhost:4000/effective/c++/2019/09/21/%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/" rel="alternate" type="text/html" title="多态基类声明virtual析构函数" /><published>2019-09-21T04:23:00-07:00</published><updated>2019-09-21T04:23:00-07:00</updated><id>http://localhost:4000/effective/c++/2019/09/21/%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0</id><content type="html" xml:base="http://localhost:4000/effective/c++/2019/09/21/%E5%A4%9A%E6%80%81%E5%9F%BA%E7%B1%BB%E5%A3%B0%E6%98%8Evirtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/">&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;一原则&quot;&gt;一、原则&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;多态基类要声明virtual析构函数&lt;/p&gt;

    &lt;p&gt;​		为了实现多态特性，我们通常声明一个基类包含要提供给外部使用的接口/功能（具体形式为基类中声明的特定公共成员函数），然后由派生类来各自实现这些接口。如一个支付类，提供支付功能，而具体是微信支付还是支付宝支付由不同的派生类实现，而调用者并不需要知道实现细节。&lt;/p&gt;

    &lt;p&gt;​		调用者得到一个基类指针，指向的可以是不同派生类对象，通过这个基类指针调用虚函数方法时，实际调用的是相应派生类的方法，从而实现了多态：使用同一个基类指针，根据指向派生类对象的不同，调用不同的方法实现。&lt;/p&gt;

    &lt;p&gt;​		假设以下这种情况，&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Base class: Animal&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
   
&lt;span class=&quot;c1&quot;&gt;// Cat&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;Cat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Cat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      	&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;miao miao~~&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
   
&lt;span class=&quot;c1&quot;&gt;// Dog&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dog&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;Dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  	&lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  	&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;shout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      	&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hou hou~~&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
   
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  	&lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;​		如果多态基类Animal没有将析构函数声明为virtual，当delete a；语句销毁对象的时候，只能调用的是Animal基类析构函数，释放Animal基类申请的资源，而无法调用派生类Cat类的析构函数，释放Cat类申请的资源，从而造成&lt;strong&gt;局部销毁&lt;/strong&gt;现象，引发资源泄露问题。&lt;/p&gt;

    &lt;p&gt;​		所以多态基类的析构函数要声明为virtual函数，一个原则就是如果基类中有至少一个virtual函数，那么其析构函数也应该声明为virtual。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;非基类或不打算实现多态的基类不要声明virtual函数（包括virtual析构函数）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Your Name</name></author><summary type="html">[TOC]</summary></entry><entry><title type="html">C++虚函数/纯虚函数详解</title><link href="http://localhost:4000/learn/cpp/2019/09/20/C++%E8%99%9A%E5%87%BD%E6%95%B0%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/" rel="alternate" type="text/html" title="C++虚函数/纯虚函数详解" /><published>2019-09-20T18:55:00-07:00</published><updated>2019-09-20T18:55:00-07:00</updated><id>http://localhost:4000/learn/cpp/2019/09/20/C++%E8%99%9A%E5%87%BD%E6%95%B0%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3</id><content type="html" xml:base="http://localhost:4000/learn/cpp/2019/09/20/C++%E8%99%9A%E5%87%BD%E6%95%B0%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/">&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&quot;一基本概念&quot;&gt;一、基本概念&lt;/h2&gt;

&lt;h3 id=&quot;1-什么是虚函数&quot;&gt;1. 什么是虚函数？&lt;/h3&gt;

&lt;h3 id=&quot;2-什么是纯虚函数&quot;&gt;2. 什么是纯虚函数？&lt;/h3&gt;

&lt;h2 id=&quot;二使用模式与最佳实践&quot;&gt;二、使用模式与最佳实践&lt;/h2&gt;

&lt;h3 id=&quot;1-如何创建虚函数纯虚函数&quot;&gt;1. 如何创建虚函数、纯虚函数？&lt;/h3&gt;

&lt;p&gt;###&lt;/p&gt;

&lt;p&gt;// todo&lt;/p&gt;

&lt;h2 id=&quot;三底层实现原理&quot;&gt;三、底层实现原理&lt;/h2&gt;

&lt;p&gt;// todo&lt;/p&gt;

&lt;h2 id=&quot;四总结&quot;&gt;四、总结&lt;/h2&gt;</content><author><name>Your Name</name></author><summary type="html">[TOC]</summary></entry><entry><title type="html">C/C++易混淆概念记录</title><link href="http://localhost:4000/learn/2019/08/19/CC++%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5/" rel="alternate" type="text/html" title="C/C++易混淆概念记录" /><published>2019-08-19T08:12:00-07:00</published><updated>2019-08-19T08:12:00-07:00</updated><id>http://localhost:4000/learn/2019/08/19/CC++%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5</id><content type="html" xml:base="http://localhost:4000/learn/2019/08/19/CC++%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E6%A6%82%E5%BF%B5/">&lt;h2 id=&quot;基础&quot;&gt;基础&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;指针为NULL与nullptr的区别？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;void与void* 的区别？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数组指针与指针数组区别？&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;数组指针（也称行指针）
定义 int (*p)[n];
()优先级高，首先说明p是一个指针，指向一个整型的一维数组，这个一维数组的长度是n，也可以说是p的步长。也就是说执行p+1时，p要跨过n个整型数据的长度。
   
如要将二维数组赋给一指针，应这样赋值：
int a[3][4];
int (*p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。
 p=a;        //将该二维数组的首地址赋给p，也就是a[0]或&amp;amp;a[0][0]
 p++;       //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][]
   
所以数组指针也称指向一维数组的指针，亦称行指针。
   
指针数组
定义 int *p[n];
[]优先级高，先与p结合成为一个数组，再由int*说明这是一个整型指针数组，它有n个指针类型的数组元素。这里执行p+1是错误的，这样赋值也是错误的：p=a；因为p是个不可知的表示，只存在p[0]、p[1]、p[2]...p[n-1],而且它们分别是指针变量可以用来存放变量地址。但可以这样 *p=a; 这里*p表示指针数组第一个元素的值，a的首地址的值。
如要将二维数组赋给一指针数组:
int *p[3];
int a[3][4];
for(i=0;i&amp;lt;3;i++)
p[i]=a[i];
这里int *p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]
所以要分别赋值。
   
这样两者的区别就豁然开朗了，数组指针只是一个指针变量，似乎是C语言里专门用来指向二维数组的，它占有内存中一个指针的存储空间。指针数组是多个指针变量，以数组形式存在内存当中，占有多个指针的存储空间。
还需要说明的一点就是，同时用来指向二维数组时，其引用和用数组名引用都是一样的。
比如要表示数组中i行j列一个元素：
*(p[i]+j)、*(*(p+i)+j)、(*(p+i))[j]、p[i][j]
   
    
   
优先级：()&amp;gt;[]&amp;gt;*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;int / long/ long long？&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;On major 32-bit platforms:
int is 32 bits
long is 32 bits as well
long long is 64 bits
   
On major 64-bit platforms:
   
int is 32 bits
long is either 32 or 64 bits
long long is 64 bits as well
Going by the standard:
   
int must be at least 16 bits
long must be at least 32 bits
long long must be at least 64 bits
Correct me if I'm wrong.
   
If you need a specific integer size for a particular application, rather than trusting the compiler to pick the size you want, #include &amp;lt;stdint.h&amp;gt; (or &amp;lt;cstdint&amp;gt;) so you can use these types:
   
int8_t and uint8_t
int16_t and uint16_t
int32_t and uint32_t
int64_t and uint64_t
You may also be interested in #include &amp;lt;stddef.h&amp;gt; (or &amp;lt;cstddef&amp;gt;):
   
size_t
ptrdiff_t
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;高级&quot;&gt;高级&lt;/h2&gt;</content><author><name>Your Name</name></author><summary type="html">基础</summary></entry><entry><title type="html">hadoop streaming 多路输出</title><link href="http://localhost:4000/learn/2019/06/10/hadoop-streaming-%E5%A4%9A%E8%B7%AF%E8%BE%93%E5%87%BA/" rel="alternate" type="text/html" title="hadoop streaming 多路输出" /><published>2019-06-10T06:12:00-07:00</published><updated>2019-06-10T06:12:00-07:00</updated><id>http://localhost:4000/learn/2019/06/10/hadoop-streaming-%E5%A4%9A%E8%B7%AF%E8%BE%93%E5%87%BA</id><content type="html" xml:base="http://localhost:4000/learn/2019/06/10/hadoop-streaming-%E5%A4%9A%E8%B7%AF%E8%BE%93%E5%87%BA/">&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;多路输出指定outputformat&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-outputformat org.apache.hadoop.mapred.lib.SuffixMultipleTextOutputFormat&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-outputformat org.apache.hadoop.mapred.lib.SuffixMultipleSequenceFileOutputFormat&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在reduce的输出&amp;lt;key, value&amp;gt;变为输出&amp;lt;key, value#X&amp;gt;, #X后缀中X是A~Z的26个英文字母&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;坑：对于TextInputFormat，reduce输出数据经常是一行一行的文本，如果一行的中间没有”\t”的话，就代表value为空，如果直接将”#X”后缀放在行尾，”#X”会作为key的一部分而不是value的一部分（因为加上后缀后一行中间仍然没有”\t”）这样会导致出错，解决的方式是在#X后缀前面添加”\t”使它变成value的一部分而不是key的一部分&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Your Name</name></author><summary type="html">多路输出指定outputformat</summary></entry><entry><title type="html">taglist-vim快捷键</title><link href="http://localhost:4000/learn/2019/06/10/taglist-vim%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="alternate" type="text/html" title="taglist-vim快捷键" /><published>2019-06-10T06:04:00-07:00</published><updated>2019-06-10T06:04:00-07:00</updated><id>http://localhost:4000/learn/2019/06/10/taglist-vim%E5%BF%AB%E6%8D%B7%E9%94%AE</id><content type="html" xml:base="http://localhost:4000/learn/2019/06/10/taglist-vim%E5%BF%AB%E6%8D%B7%E9%94%AE/">&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&amp;lt;CR&amp;gt;          跳到光标下tag所定义的位置，用鼠标双击此tag功能也一样
o             在一个新打开的窗口中显示光标下tag
&amp;lt;Space&amp;gt;       显示光标下tag的原型定义
u             更新taglist窗口中的tag
s             更改排序方式，在按名字排序和按出现顺序排序间切换
x             taglist窗口放大和缩小，方便查看较长的tag
+             打开一个折叠，同zo
-             将tag折叠起来，同zc
*             打开所有的折叠，同zR
=             将所有tag折叠起来，同zM
[[            跳到前一个文件
]]            跳到后一个文件
q             关闭taglist窗口
&amp;lt;F1&amp;gt;          显示帮助 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Your Name</name></author><summary type="html">```</summary></entry><entry><title type="html">hadoop partitioner类</title><link href="http://localhost:4000/learn/2019/06/10/hadoop-Partitioner%E7%B1%BB/" rel="alternate" type="text/html" title="hadoop partitioner类" /><published>2019-06-10T06:04:00-07:00</published><updated>2019-06-10T06:04:00-07:00</updated><id>http://localhost:4000/learn/2019/06/10/hadoop-Partitioner%E7%B1%BB</id><content type="html" xml:base="http://localhost:4000/learn/2019/06/10/hadoop-Partitioner%E7%B1%BB/">&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;指定partitioner类（二次排序）&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-partitioner org.apache.hadoop.mapred.lib.KeyFieldBasedPartitioner&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定自定义方法切分行来形成key/value对&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-jobconf stream.reduce.output.field.separator=SEP # 指定分隔符，默认是tab符&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-jobconf stream.num.reduce.output.fields=NUM # 指定在第n（n&amp;gt;=1）个分隔符分隔，而不是默认的第1个&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定map输出数据分桶的列数（基于key值的前缀）&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;map.output.key.field.separator=. # 指定切分map输出的分隔符为. &lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;num.key.fields.for.partition=2 # 指定使用key的前2个块部分来切分map输出&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Your Name</name></author><summary type="html">指定partitioner类（二次排序）</summary></entry><entry><title type="html">shell test命令常用条件</title><link href="http://localhost:4000/learn/2018/09/28/shell-test-condition/" rel="alternate" type="text/html" title="shell test命令常用条件" /><published>2018-09-28T18:33:00-07:00</published><updated>2018-09-28T18:33:00-07:00</updated><id>http://localhost:4000/learn/2018/09/28/shell-test-condition</id><content type="html" xml:base="http://localhost:4000/learn/2018/09/28/shell-test-condition/">&lt;h2 id=&quot;数值测试&quot;&gt;数值测试&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-eq&lt;/td&gt;
      &lt;td&gt;等于则为真&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-ne&lt;/td&gt;
      &lt;td&gt;不等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-gt&lt;/td&gt;
      &lt;td&gt;大于&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-ge&lt;/td&gt;
      &lt;td&gt;大于等于&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-lt&lt;/td&gt;
      &lt;td&gt;小于&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-le&lt;/td&gt;
      &lt;td&gt;小于等于&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;字符串测试&quot;&gt;字符串测试&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;=&lt;/td&gt;
      &lt;td&gt;等于则为真&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;!=&lt;/td&gt;
      &lt;td&gt;不想等&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-z 字符串&lt;/td&gt;
      &lt;td&gt;字符串长度为零则为真&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-n 字符串&lt;/td&gt;
      &lt;td&gt;字符串长度不为零则为真&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;文件测试&quot;&gt;文件测试&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-e 文件名&lt;/td&gt;
      &lt;td&gt;文件存在则为真&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-r 文件名&lt;/td&gt;
      &lt;td&gt;文件可读则为真&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-w 文件名&lt;/td&gt;
      &lt;td&gt;文件可写则为真&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-x 文件名&lt;/td&gt;
      &lt;td&gt;文件可执行则为真&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-s 文件名&lt;/td&gt;
      &lt;td&gt;文件存在且至少有一个字符则为真&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-d 文件名&lt;/td&gt;
      &lt;td&gt;文件存在且为目录则为真&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-f 文件名&lt;/td&gt;
      &lt;td&gt;文件存在且为普通文件则为真&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-c 文件名&lt;/td&gt;
      &lt;td&gt;文件存在且为字符型特殊文件？则为真&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-b 文件名&lt;/td&gt;
      &lt;td&gt;文件存在且为块特殊文件则为真&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name>Your Name</name></author><summary type="html">数值测试</summary></entry><entry><title type="html">hadoop 常用环境变量</title><link href="http://localhost:4000/learn/2018/09/27/hadoop%E5%B8%B8%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/" rel="alternate" type="text/html" title="hadoop 常用环境变量" /><published>2018-09-27T23:53:00-07:00</published><updated>2018-09-27T23:53:00-07:00</updated><id>http://localhost:4000/learn/2018/09/27/hadoop%E5%B8%B8%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F</id><content type="html" xml:base="http://localhost:4000/learn/2018/09/27/hadoop%E5%B8%B8%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;环境变量名&lt;/th&gt;
      &lt;th&gt;意义解释&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;HADOOP_HOME&lt;/td&gt;
      &lt;td&gt;计算节点上配置的hadoop client路径&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LD_LIBRARY_PATH&lt;/td&gt;
      &lt;td&gt;计算节点上加载库文件的路径列表&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PWD&lt;/td&gt;
      &lt;td&gt;当前工作目录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;df_block_size&lt;/td&gt;
      &lt;td&gt;当前设置的HDFS文件块大小&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;map_input_file&lt;/td&gt;
      &lt;td&gt;mapper正在处理得输入文件路径，包含文件名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mapred_job_id&lt;/td&gt;
      &lt;td&gt;当前作业ID&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mapred_job_name&lt;/td&gt;
      &lt;td&gt;当前作业名称&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mapred_tip_id&lt;/td&gt;
      &lt;td&gt;当前任务的第几次重试&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mapred_task_id&lt;/td&gt;
      &lt;td&gt;任务ID&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mapred_task_is_map&lt;/td&gt;
      &lt;td&gt;当前任务是否为map&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mapred_output_dir&lt;/td&gt;
      &lt;td&gt;计算输出路径&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mapred_map_tasks&lt;/td&gt;
      &lt;td&gt;计算的map任务数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mapred_reduce_tasks&lt;/td&gt;
      &lt;td&gt;计算的reduce的任务数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mapred_work_output_dir&lt;/td&gt;
      &lt;td&gt;task临时输出目录&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mapred_output_dir&lt;/td&gt;
      &lt;td&gt;job输出路径&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;mapred_work_output_dir解释&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了避免冲突，Map/Reduce框架为每次尝试执行任务都建立和维护一个特殊的&lt;/p&gt;

&lt;p&gt;${mapred.output.dir}/&lt;em&gt;temporary/&lt;/em&gt;​${taskid}子目录，这个目录位于本次尝试执行任务输出结果所在的FileSystem上，可以通过 ${mapred.work.output.dir}来访问这个子目录。 对于成功完成的任务尝试，只有${mapred.output.dir}/&lt;em&gt;temporary/&lt;/em&gt;${taskid}下的文件会&lt;em&gt;移动&lt;/em&gt;到${mapred.output.dir}。当然，框架会丢弃那些失败的任务尝试的子目录。这种处理过程对于应用程序来说是完全透明的。&lt;/p&gt;

&lt;p&gt;在任务执行期间，应用程序在写文件时可以利用这个特性，比如 通过&lt;a href=&quot;http://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#getWorkOutputPath(org.apache.hadoop.mapred.JobConf)&quot;&gt; FileOutputFormat.getWorkOutputPath()&lt;/a&gt;获得${mapred.work.output.dir}目录， 并在其下创建任意任务执行时所需的side-file，框架在任务尝试成功时会马上移动这些文件，因此不需要在程序内为每次任务尝试选取一个独一无二的名字。&lt;/p&gt;

&lt;p&gt;注意：在每次任务尝试执行期间，${mapred.work.output.dir} 的值实际上是 ​${mapred.output.dir}/&lt;em&gt;temporary/&lt;/em&gt;{$taskid}，这个值是Map/Reduce框架创建的。 所以使用这个特性的方法是，在&lt;a href=&quot;http://hadoop.apache.org/core/docs/r0.18.2/api/org/apache/hadoop/mapred/FileOutputFormat.html#getWorkOutputPath(org.apache.hadoop.mapred.JobConf)&quot;&gt; FileOutputFormat.getWorkOutputPath() &lt;/a&gt;路径下创建side-file即可。&lt;/p&gt;</content><author><name>Your Name</name></author><summary type="html">环境变量名 意义解释 HADOOP_HOME 计算节点上配置的hadoop client路径 LD_LIBRARY_PATH 计算节点上加载库文件的路径列表 PWD 当前工作目录 df_block_size 当前设置的HDFS文件块大小 map_input_file mapper正在处理得输入文件路径，包含文件名 mapred_job_id 当前作业ID mapred_job_name 当前作业名称 mapred_tip_id 当前任务的第几次重试 mapred_task_id 任务ID mapred_task_is_map 当前任务是否为map mapred_output_dir 计算输出路径 mapred_map_tasks 计算的map任务数 mapred_reduce_tasks 计算的reduce的任务数 mapred_work_output_dir task临时输出目录 mapred_output_dir job输出路径</summary></entry><entry><title type="html">你了解字符集、字符编码吗？</title><link href="http://localhost:4000/learn/2018/09/27/%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%AD%97%E7%AC%A6%E9%9B%86-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%90%97/" rel="alternate" type="text/html" title="你了解字符集、字符编码吗？" /><published>2018-09-27T21:49:00-07:00</published><updated>2018-09-27T21:49:00-07:00</updated><id>http://localhost:4000/learn/2018/09/27/%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%AD%97%E7%AC%A6%E9%9B%86%E3%80%81%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%90%97%3F</id><content type="html" xml:base="http://localhost:4000/learn/2018/09/27/%E4%BD%A0%E4%BA%86%E8%A7%A3%E5%AD%97%E7%AC%A6%E9%9B%86-%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%90%97/">&lt;h3 id=&quot;你了解字符集字符编码吗&quot;&gt;你了解字符集、字符编码吗？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ASCII&lt;/strong&gt;: 使用一个字节表示一个字符，实际使用的只有一个字节的低7位，第8位永远是0，因此最多只能表示2^7=128个字符，主要用来表示基础的拉丁字符，如英文字母，数字等，包括95个可打印字符和33个控制字符；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ISO 8859-n(n=1,2,3…11,13…16,没有12)&lt;/strong&gt;: 利用了ASCII字符集没有使用的最高位，使最多可表示的字符扩展到2^8=256个字符，可以支持许多欧洲国家的语言文字；
    &lt;ul&gt;
      &lt;li&gt;其中0x00 ~ 0x7f范围是与ASCII兼容的&lt;/li&gt;
      &lt;li&gt;0x80 ~ 0xff范围是在ASCII基础上的扩展字符集&lt;/li&gt;
      &lt;li&gt;ISO 8859-n 字符集有多个系列，分别用于不同的欧洲语言地区，如西欧，北欧，东欧&lt;/li&gt;
      &lt;li&gt;Latin-1是ISO 8859-1的别名&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;GB2312&lt;/strong&gt;: 为了表示更大规模的汉字字符集，我国制定了国家简体中文字符集，即GB2312，使用一个字节表示拉丁字母来兼容ASCII，汉字使用两个字节表示，因此GB2312是变字节的字符集，但除了简体汉字外，还有繁体汉字及中日韩文字需要表示，因此还有BIG5，GBK，GB18030几种字符集，请看下表它们的区别；&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;GB2312&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;BIG5&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;GBK&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;GB18030&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;作用&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;国家简体中文字符集&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;统一繁体字符集&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;GB2312扩展，加入对繁体字的支持&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;中日韩文字编码&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;字节数&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;变字节：1字节 - 兼容ASCII        2字节 - 汉字&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2字节&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2字节&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;变字节：1字节 - 兼容ASCII  2字节，4字节&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;范围&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;能表示7445个符号，包括6763个汉字&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;能表示21886个符号&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;能表示21886个符号&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;能表示27484个符号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;兼容性&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;兼容ASCII， 0x00 ~ 0x7F 与ASCII保持一致&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;兼容ASCII，但与GB2312有冲突&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;兼容GB2312&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;兼容GB2312&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Unicode&lt;/strong&gt;： 终极字符集，全世界通用，用4个字节表示一个字符，可以表达的字符数理论上可达21亿左右个。但每个字符用4个字节表示总觉得有些浪费啊，毕竟字节是要占存储空间的啊，还有一个问题是如何让计算机了解你是在用4个字节表示一个字符而不是4个ASCII表示4个字符 ，这两个问题一直困扰着Unicode的发展推广。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;UTF-8&lt;/strong&gt;: 直到出现UTF-8解决这两个问题，UTF-8不是一种字符集，而是对Unicode字符集的一种实现，这也意味着Unicode有其他实现方式，如UTF-16，UTF-32。而如此牛逼的UTF-8，话说当初是大神Ben Thomason吃饭的时候在一张餐巾纸上设计出来的！！UTF-8的实现规则如下：
    &lt;ul&gt;
      &lt;li&gt;对单字节字符，字节的第一位为0，后7位为该字符实际的Unicode码，所以对于拉丁字母，UTF-8与ASCII一致。&lt;/li&gt;
      &lt;li&gt;对于n(n &amp;gt; 1)字节字符，第一个字节前n位都设为1，第n + 1位为0，后面字节的前两位均为10，剩下没有提及的位，就是字符的Unicode编码；&lt;/li&gt;
      &lt;li&gt;另外需要注意的是：UTF-8与GBK，GB2312这些汉字编码完全不兼容的。&lt;/li&gt;
      &lt;li&gt;UTF-8字符编码理论可以表示的字符总数为：2^7 + 2^11 + 2^16 + 2^21 = 2164864,  两百多万个！！！&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;常见问题及解答&quot;&gt;常见问题及解答&lt;/h3&gt;

&lt;h3 id=&quot;1windows-notepad中的编码ansi保存选项代表什么含义&quot;&gt;1.windows Notepad中的编码ANSI保存选项，代表什么含义？&lt;/h3&gt;

&lt;p&gt;ANSI是windows的默认的编码方式，对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。所以，&lt;strong&gt;如果将一个UTF-8编码的文件，另存为ANSI的方式，对于中文部分会产生乱码&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;2什么是utf-8的bom&quot;&gt;2.什么是UTF-8的BOM？&lt;/h3&gt;

&lt;p&gt;BOM的全称是Byte Order Mark，BOM是微软给UTF-8编码加上的，用于标识文件使用的是UTF-8编码，即在UTF-8编码的文件起始位置，加入三个字节“EE BB BF”。这是微软特有的，标准并不推荐包含BOM的方式。采用加BOM的UTF-8编码文件，对于一些只支持标准UTF-8编码的环境，可能导致问题。比如，在Go语言编程中，对于包含BOM的代码文件，会导致编译出错。详细可见我的&lt;a href=&quot;http://sharecore.info/blog/2013/04/05/parse-csv-to-sql-for-insert/&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.jobbole.com/76376/&quot; title=&quot;字符编码常识及问题解析&quot;&gt;http://blog.jobbole.com/76376/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Your Name</name></author><summary type="html">你了解字符集、字符编码吗？</summary></entry></feed>